#import mathplotlib
import pylab as pl
import numpy as np
import decimal as d
import math

## SIR model that returns dictionary of S, I and R
def get_input(S0, I0, R0, t, gamma, beta, control_start, _lambda):
   try:
      S0+=0
   except TypeError:
      print('S0 must be an integer')
   try:
      I0+=0
   except TypeError:
      print('I0 must be an integer')
   try:
      R0+=0
   except TypeError:
      print('R0 must be an integer')
   try:
      t+=0
   except TypeError:
      print('t must be an integer')
   try:
      control_start+=0
   except TypeError:
      print('control_start must be an integer')
   try:
      # strs added to stop many decimal places being added beyond
      # what user puts in
      gamma = d.Decimal(str(gamma))
   except d.InvalidOpperation:
      print('Gamma is not a decimal')
   try:
      beta = d.Decimal(str(beta))
   except d.InvalidOpperation:
      print('Beta is not a decimal')
   try:
      _lambda = d.Decimal(str(_lambda))
   except d.InvalidOpperation:
      print('Lambda is not a decimal')
   input_dict = {'S0': S0,
                'I0': I0,
                'R0': R0,
                'time': t,
                'gamma':gamma,
                'beta':beta,
                'cs':control_start,
                'lambda':_lambda,
                'pop': sum([S0,I0,R0])}
   return(input_dict)

def add_timestep(num, list):
   list.append(num)
   return(list)

def SIR(input_dict, time, end):
   if end==0:
      pass
   while time < end:
      if time <= 1:
         S = input_dict['S0']
         I = input_dict['I0']
         R = input_dict['R0']
         S_list = add_timestep(S, [])
         I_list = add_timestep(I, [])
         R_list = add_timestep(R, [])
      dS = - input_dict['beta']*S*I/input_dict['pop']
      dI = input_dict['beta']*S*I/input_dict['pop'] - input_dict['gamma']*I
      dR = input_dict['gamma']*I
      S = S + dS
      I = I + dI
      R = R + dR
      S_list = add_timestep(S, S_list)
      I_list = add_timestep(I, I_list)
      R_list = add_timestep(R, R_list)
      time = time + 1
   return(S_list, I_list, R_list, time)

### SIR with control

def SIR_withcntl(input_dict, time, end):
   c = input_dict['cs']
   while time < end:
      if time < 1:
         print('time<1')
         print(time)
         print(c)
         sir_before_control = SIR(input_dict, time, c)
         S = sir_before_control[0][len(sir_before_control[0])-1]
         I = sir_before_control[1][len(sir_before_control[1])-1]
         R = sir_before_control[2][len(sir_before_control[2])-1]
         time = sir_before_control[3]
      if time >= c:
         dS = - input_dict['beta']*S*I/input_dict['pop'] - input_dict['lambda'] * S
      else:
         dS = - input_dict['beta']*S*I/input_dict['pop']
      dI = input_dict['beta']*S*I/input_dict['pop'] - input_dict['gamma']*I
      dR = input_dict['gamma']*I
      S = S + dS
      I = I + dI
      R = R + dR
      S_list = add_timestep(S, sir_before_control[0])
      I_list = add_timestep(I, sir_before_control[1])
      R_list = add_timestep(R, sir_before_control[2])
      time = time + 1
   return(S_list, I_list, R_list, time)

### get kappa
def get_kappa(input_dict, time, end):
   I_with_control = SIR_withcntl(input_dict, time, end)[1]
   I_no_control = SIR(input_dict, time, end)[1]
   kappa = sum(I_with_control)/sum(I_no_control)
   return(kappa)

### Graph SIR

### Get the peak intensity

def peak_intensity(input_dict):
   rho = input_dict['gamma']/input_dict['beta']
   I0 = input_dict['I0']/input_dict['pop']
   S0 = input_dict['S0']/input_dict['pop']
   peak_intensity = I0 + S0 - rho * (math.log(S0)+1 - math.log(rho))
   return(peak_intensity)

